package main

import (
	"fmt"
	"time"
)

//sync(シィンク)
//synchronize シンクロナイズ　(同期する)
//ミューテックスによる同期処理
//並行処理を実現するための重要なパッケージ
//複数のgoroutineが安全にデータを共有し、同期するためのツールを提供している

//このコードはレースコンディションについて考えるコード
//このコードを sync の Mutex機能 による排他制御で解決する
/*
	レースコンディション（Race Condition）は、コンピュータプログラムにおいて、
	複数のスレッドやプロセスが共有されたリソース（変数、ファイル、データ構造な
	ど）に同時にアクセスし、その結果予測できない動作が発生する可能性がある状態
	を指す
*/

var st struct{ A, B, C int } //匿名構造体
//普通の構造体はtype 型名 struct{}でまず型の定義をして、その型を持つ変数の宣言が必要
//匿名構造体は型の定義をせずに一気に変数を作れる

func UpdateAndPrint(n int) {
	st.A = n
	time.Sleep(time.Microsecond)
	st.B = n
	time.Sleep(time.Microsecond)
	st.C = n
	time.Sleep(time.Microsecond)
	fmt.Println(st)
}

func main() {
	for i := 0; i < 5; i++ {
		go func() {
			for i := 0; i < 1000; i++ {
				UpdateAndPrint(i)
			}
		}()
		//無名関数をゴルーチンで動かしている
	}
	for {

	}
	//この無限ループはゴルーチンを終了させないようにするため
	//main関数が終了すると全体が終了してしまうため無限のforでプログラムが終わらないようにする
	//本当はsync.WaitGroup()でゴルーチンの終了を待って終了させるべき
}

//goroutineの処理の順番について
/*
	外側の for ループは内側の for ループの終了を待つ必要はありません。Go言語では、
	ゴルーチン（go キーワードで起動された非同期タスク）が使用されているため、ゴルー
	チンはバックグラウンドで非同期に実行されます。したがって、外側の for ループはゴ
	ルーチンの終了を待たずに進行し、5つのゴルーチンが同時に実行されます。

	外側の for ループは5回繰り返され、各イテレーションで新しいゴルーチンが生成されま
	す。それぞれのゴルーチンは内側の for ループを1000回繰り返し、UpdateAndPrint 関
	数を呼び出します。したがって、5つのゴルーチンが非同期に動作し、内側の for ループ
	が終了することなく、外側の for ループのカウントが進んでいきます。

	このプログラムは非同期に実行され、外側の for ループはすぐにゴルーチンを起動して次のイ
	テレーションに進むため、内側の for ループの終了を待つ必要はありません。したがって、内
	側と外側の for ループは同時に進行します。

*/
