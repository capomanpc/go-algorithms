package main

import (
	"fmt"
	"regexp"
)

//regexp-レジェックス、リージェックス
//Regular Expression 正規表現

func main() {
	//正規表現のフラグ
	/*
		フラグ一覧
		フラグは()の中に書く
		?は普通の文字ではなくフラグだと区別するための文字


		i 大文字小文字を区別しない
		m マルチラインモード(^と$がテキストの開始と終了だけでなく、各行の開始と終了にもマッチするようになる)
		s .が\nにマッチ(デフォルトでは"."は改行文字以外のすべての文字にマッチする)
		U 最小マッチ￥への変換(x*はx*?へ、x+はx+?へ)
		　通常であれば出来る限り長くマッチしようとするがこのフラグを追加することで最小マッチになる

		-m　このように-を付けることでmのフラグの無効化ができる
			大きな意味を持つフラグから小さなフラグを無効化したい場合に使う
	*/

	re3 := regexp.MustCompile(`(?i-ms)abc`) //i有効,ms無効
	match := re3.MatchString("ABC")
	fmt.Println(match) //true

	//幅を持たない正規表現のパターン(メタ文字)
	/*
		パターン一覧(これらを指定することで文末や文頭にマッチする)

		^ 文頭を表す文字(mフラグが有効な場合は行頭にもマッチ)
		$ 文末を表す文字(mフラグが有効な場合は行末にもマッチ)

		\A 文頭(mフラグが有効でも機能は変わらない)
		\z 文末(mフラグが有効でも機能は変わらない)

		\b ASCIIによるワード境界(ASCII文字と非ASCII文字の境界の位置でマッチする)
		\B 非ASCIIによるワード境界

	*/

	re4 := regexp.MustCompile(`^ABC$`) //文頭かつ文末になっているABC
	//バッククォートで囲まれるとエスケープシーケンス(\nなど)が生の文字列リテラルとなる
	//今回の場合バッククォートの中にエスケープシーケンスはないので""で囲む場合と同じ
	match = re4.MatchString("ABC")
	fmt.Println(match)                 //true
	match = re4.MatchString("  ABC  ") //前後に空白(幅がある場合は)
	fmt.Println(match)                 //false

	//繰り返しを表す正規表現(メタ文字)
	//「パターンの繰り返し回数」を指定するメタ文字は「量指定子」と呼ばれる
	/*
		繰り返しのパターン

		x* 0回以上繰り返すx(最大マッチ)
		x+ 1回以上繰り返すx(最大マッチ)
		x? 0回以上一回以下繰り返すx
		x{n,m} n回以上m回以下繰り返すx(最大マッチ)
		x{n, } n回以上繰り返すx(最大マッチ)
		x{n} n回繰り返すx(最大マッチ)

		x*? 0回以上繰り返すx(最小マッチ)
		x+? 1回以上繰り返すx(最小マッチ)
		x?? 0回以上一回以下繰り返すx
		x{n,m}? n回以上m回以下繰り返すx(最小マッチ)
		x{n, }? n回以上繰り返すx(最小マッチ)
		x{n}? n回繰り返すx(最小マッチ)

		//x*を使った例
		チャーシューたっ*くさん

		// マッチする文字列
		チャーシューたくさん
		チャーシューたっくさん
		チャーシューたっっっっっっっっくさん
		小さい"っ"があってもなくてもマッチする
	*/

	re6 := regexp.MustCompile("a+b*")
	fmt.Println(re6.MatchString("ab"))           //true
	fmt.Println(re6.MatchString("a"))            //true
	fmt.Println(re6.MatchString("aaaabbbbbbbb")) //true
	fmt.Println(re6.MatchString("b"))            //false

	//正規表現の文字クラス
	re8 := regexp.MustCompile(`[XYZ]`) //XYZのいずれかにマッチ
	fmt.Println(re8.MatchString("Y"))  //true

	re9 := regexp.MustCompile(`^[0-9A-Za-z_]{3}$`) //0-9 OR A-Z OR a-z OR _ が3回繰り返す それと文末かつ文頭
	fmt.Println(re9.MatchString("ABC"))            //true
	fmt.Println(re9.MatchString("abcdefg"))        //false

	re10 := regexp.MustCompile(`[^0-9A-Za-z_]`) //英数字とアンダースコア以外にマッチ　それと文頭
	fmt.Println(re10.MatchString("ABC"))        //false
	fmt.Println(re10.MatchString("あ"))          //true

	//正規表現のグループ
	/*
		(正規表現)　グループ(順序によるキャプチャ)
		(?:正規表現)　グループ(キャプチャされない)
		(?:P<name>正規表現)　名前付きグループ

	*/

	re11 := regexp.MustCompile(`(abc|ABC)(xyz|XYZ)`)
	/*
		以下の4つのパターンの文字列にマッチする
		abcxyz
		abcXYZ
		ABCxyz
		ABCXYZ
	*/
	fmt.Println(re11.MatchString("abcxyz")) //true
	fmt.Println(re11.MatchString("ABCXYZ")) //true
	fmt.Println(re11.MatchString("ABCxyz")) //true
	fmt.Println(re11.MatchString("ABCabc")) //false

}

/*
	正規表現パターンをバッククォートで囲む理由
	goのコンパイラでエスケープシーケンスだと解釈されるのを防ぐため

	1.regexp.MustCompile(`\b`) //バッククォートで囲ってエスケープシーケンスを無効化
	2.regexp.MustCompile("\\b") //バックスラッシュを重ねることでただの文字列にしている
	3.regexp.MustCompile("\b") //\bというエスケープシーケンスはないが動作が安定しない可能性があるのでふさわしくないコード

	1.Goのコンパイラに邪魔されることなく\bという純粋な文字列を正規表現エンジンに
	直接送ることができる。正規表現エンジンは受け取った\bという文字列から特別な文
	字列を解釈している。

	2.ダブルクォートで囲まれている中にバックスラッシュがあると、Goのコンパイラで特別な意味だと
	解釈されてしまう。そのため正規表現エンジンに\bという文字列を送りたくても、Goのコンパイラの
	せいで送れない。そこでバックスラッシュを二個重ねて"\"という文字に解釈させている。

	3.このようなコードだとまずgoのコンパイラで処理されたときに"\"のせいで
	動作がうまくいかない。Goでは"\"から始まる文字列はエスケープシーケンス
	という特別な意味を持つ文字列であるので、その次に続く正規表現エンジンに
	正しい正規表現パターンを送れなくなってしまう。



	1.バッククォートを使用（regexp.MustCompile(\\b`)`）：

	バッククォートで囲むことにより、エスケープシーケンスが無効化されます。
	このため、\bという文字列が正規表現エンジンにそのまま渡され、正規表現
	エンジンによって特別な文字列（この場合は単語の境界）として解釈されます。


	2.ダブルクォートとエスケープされたバックスラッシュ（regexp.MustCompile("\\b")）：

	ダブルクォート内では、単一のバックスラッシュ（\）が特別な意味を持つとGoのコンパイラ
	に解釈されます。正規表現エンジンに\bを送るためには、バックスラッシュを重ねて\\bとす
	る必要があります。


	3.不適切な使用（regexp.MustCompile("\b")）：

	ダブルクォートと単一のバックスラッシュを使用した場合、\bはGoのコンパイラによって
	エスケープシーケンスとして解釈されます。これは通常のバックスペース文字を意味し、
	正しい正規表現パターンとして正規表現エンジンに送られません。
	要約すると、正規表現パターンをバッククォートで囲む主な目的は、Go言語のコンパイラ
	によるエスケープシーケンスの特殊な解釈を回避し、正規表現エンジンに正確なパターン
	を直接送るためです。これにより、正規表現の処理がより直接的かつ誤解が少なくなります。

*/
